1) Descargar e instalar Docker


2) Crear el contenedor para la BD:
*IMPORTANTE: no ejecutar el siguiente comando, serviría para crear el contenedor pero lo vamos a hacer con docker-compose que es más fácil para controlarlo luego:

docker run --name plytix-DB-container -e MYSQL_ROOT_PASSWORD=root -e MYSQL_DATABASE=plytix-DB -e MYSQL_USER=plytix -e MYSQL_PASSWORD=plytix -p 3306:3306 -d mysql:8

--name plytix-DB
Asigna el nombre "plytix-DB" al contenedor. Facilita la referencia al contenedor para operaciones posteriores como iniciar, detener o eliminar.

-e MYSQL_ROOT_PASSWORD=root
Establece la variable de entorno que configura la contraseña para el usuario "root" de MySQL como "root".

-e MYSQL_DATABASE=plytix-DB
Crea automáticamente una base de datos llamada "testdb" cuando se inicia el contenedor.

-e MYSQL_USER=plytix
Crea un nuevo usuario MySQL llamado "plytix" con permisos completos sobre la base de datos especificada.

-e MYSQL_PASSWORD=plytix
Establece la contraseña "plytix" para el usuario "plytix" recién creado.

-p 3306:3306
Mapea el puerto 3306 del contenedor (donde MySQL escucha por defecto) al puerto 3306 de tu máquina host. Esto permite que te conectes a MySQL desde tu máquina usando localhost:3306.

-d
Ejecuta el contenedor en modo "detached" (segundo plano), liberando la terminal después de iniciar el contenedor.

mysql:8
Especifica la imagen Docker a usar: MySQL versión 8. Docker la descargará automáticamente si no está ya presente en tu sistema.


3) Actualizar dependencias
Añadir esto al pom.xml:

<dependency>
    <groupId>com.mysql</groupId>
    <artifactId>mysql-connector-j</artifactId>
    <scope>runtime</scope>
</dependency>


4) Actualizar la configuración de Spring (application.properties):
# Configuración de MySQL
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/testdb
spring.datasource.username=springuser
spring.datasource.password=springpassword

# Configuración JPA/Hibernate
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true

# Generación de scripts
spring.jpa.properties.jakarta.persistence.schema-generation.database.action=create
spring.jpa.properties.jakarta.persistence.schema-generation.scripts.action=create
spring.jpa.properties.jakarta.persistence.schema-generation.scripts.create-target=create.sql


5) Crear un fichero docker-compose-yml para controlar el contenedor más fácilmente en la raíz del proyecto:

services:
  mysql:
    image: mysql:8
    container_name: plytix-DB-container
    environment:
      MYSQL_ROOT_PASSWORD: root
      MYSQL_DATABASE: plytix-DB
      MYSQL_USER: plytix
      MYSQL_PASSWORD: plytix
    ports:
      - "3306:3306"
    volumes:
      - plytix-mysql-data:/var/lib/mysql
    restart: unless-stopped
    
  # Si quisiéramos añadir la aplicación Spring:
  # spring-app:
  #   build: .                 # Construye desde el Dockerfile en el directorio actual
  #   ports:
  #     - "8080:8080"
  #   depends_on:
  #     - mysql                # Indica que mysql debe iniciar primero
  #   environment:
  #     SPRING_DATASOURCE_URL: jdbc:mysql://mysql:3306/testdb

volumes:
  plytix-mysql-data:


6) Comandos básicos de Docker Compose

# Iniciar todos los servicios definidos en el contenedor
(en modo detached)
docker-compose up -d

# Parar un contenedor (docker-compose stop):
El contenedor se detiene pero permanece en el sistema.
Estado de los datos:
-Se conservan todos los datos en volúmenes (en tu caso, plytix-mysql-data)
-Se conservan los datos internos del contenedor (archivos creados dentro del contenedor no montados en volúmenes)
Uso posterior: Puedes reiniciar el mismo contenedor con docker compose start

# Eliminar el contenedor
El contenedor se elimina completamente del sistema.
Estado de los datos:
-Con docker-compose down: Los datos en volúmenes nombrados se conservan por defecto (salvo que uses --volumes)
-Con docker-compose down --volumes: Se pierden todos los datos en volúmenes
-Se pierden todos los datos internos del contenedor que no estén en volúmenes
-Con docker-compose rm -v: Se pierden los volúmenes anónimos asociados
Uso posterior: Necesitas crear un nuevo contenedor con docker compose up
docker-compose down

# Ver logs de todos los servicios
docker-compose logs

# Ver logs de un servicio específico
docker-compose logs mysql

# Reiniciar un servicio específico
docker-compose restart mysql

# Ver el estado de los servicios
docker-compose ps
